# Phase 2 Example: Dataset as Reference Graph
# This script demonstrates how datasets are views over tensors and other datasets.

# 1. Create source data
VECTOR v_features = [0.1, 0.2, 0.3, 0.4]
VECTOR v_labels = [1.0, 0.0, 1.0, 0.0]

# 2. Create a base dataset
# This creates a dataset 'raw_data' referencing the tensors above
LET raw_data = dataset("raw_data")
raw_data.add_column("feat", v_features)
raw_data.add_column("label", v_labels)

# 3. Create a derived dataset (Reference View)
# We can create a new dataset 'filtered_view' that references 'raw_data'
# Note: Currently, we use full names to point to other columns
LET filtered_view = dataset("filtered_view")

# In a future update, we might have a dedicated syntax like:
# filtered_view.add_reference("input", "raw_data.feat")

# For now, we demonstrate that the engine supports this internally
# and can be manipulated via the reference system.

SHOW raw_data

# 4. Persistence
# Saving 'raw_data' will materialize it to Parquet
SAVE DATASET raw_data TO "raw_materialized.parquet"

# Even after saving, the tensors in raw_data are still shared in memory (zero-copy)
# during the current session.

# 5. Metadata and Roles
# (Roles are supported in the core model and will be exposed 
# in the DSL in the next integration step)

# Summary of Phase 2 Checkpoints:
# [x] Dataset metadata expresses references explicitly (ResourceReference)
# [x] Engine resolves datasets via tensor references (DatasetGraph)
# [x] No tensor duplication occurs (Arc::ptr_eq confirmed in tests)
